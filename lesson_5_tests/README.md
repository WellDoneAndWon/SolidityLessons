## Типы функций
Функции бывают внутренние и внешние. Внутренние функции могут быть вызваны только из текущего контракта, в котором объявлена эта функция. Внешние функции состоят из адреса и сигнатуры, которые могут быть переданы через возвращаемое значение вызова внешней функции.
```solidity
function (<parameter types>) {internal|external} [pure|view|payable] [returns (<return types>)]
```
1. ``<parameter types>`` – это параметры, которые вы передаете в функцию. Если вы ничего не передаете в функцию, то параметры не указываются.
2. ``{internal|external}`` – это указание на то, является ли функция внутренней или внешней. Если не указывать, то по умолчанию, функция будет считаться внутренней (internal). Если же функция внешняя, то вы должны явно указать ей значение external.
3. ``[pure|view|payable]`` – это определение характера функции, они могут быть следующими:
    + ``pure`` (вызывается через call, но не может читать внешние данные) – функция, которая делает расчет только на основе переданных в нее аргументов, при этом она не читает и не изменяет переменные состояния самого контракта.
    ```solidity
    function rate(uint amount) public pure returns(uint) {
        return amount * 3;
    }
    ```
   + ``view`` (вызывается через call) – функция доступная только для чтения данных, что дает гарантию о том, что переменные состояния в ней не изменятся (ставится по умолчанию, если не задан другой характер функции).
    ```solidity
    function getBalance() public view returns(uint) {
        uint balance = address(this).balance;
        return balance; //явное explicitly
    }
    ```
     ```solidity
    function getBalance() public view returns(uint balance) {
        balance = address(this).balance; //неявное implicitly
    }
    ```
   + ``payable`` – позволяет функции получать эфир при её вызове.
1. ``returns (<return types>)`` – это возвращаемые типы функции. Если ваша функция ничего не должна возвращать, то returns не указывается. Если возвращаемых переменных несколько, то указыаете их через запятую с объявлением их типа.


## Область видимости
+ ``public`` – публичные функции являются частью интерфейса контракта и могут вызываться либо внутри контракта как internal, либо вызываться внешне как external. При этом происходит копирование массива в memory, тем самым требуя больше памяти чем использование internal или external. (может вызывать клиент как извне, так и контракт через другие функции, переменные и прочее, из внутри контракта)
+ ``external`` – внешние функции являются частью контракта, что означает, что их можно вызывать из других контрактов и через транзакции. Чтение идет напрямую из calldata. Внешняя функция f не может быть вызвана изнутри(можно обращаться только извне, например, отправлять средства через метамаск или через фронтент)
+ ``internal`` – доступ к этим функциям и переменным состояния можно получить только из текущего контракта или его наследников без использования this. Это уровень видимости по умолчанию для переменных состояния. (можно обращаться только изнутри самого смарт-котракта, также те контракты, которые данному контракту наследуют)
+ ``private``  – частные функции и переменные состояния видны только для контрактах, в котором они определены. Но не видны в наследуемых от них контрактах. (можно обращаться только изнутри самого смарт-котракта, но не из его потомков)

## Специальные функции fallback и receive
+ fallback функция исполняется при вызове контракта, если ни одна из других его функций не соответствует заданной сигнатуре, т.е. по сути если вызывается несуществующая в контракте функция. Также fallback исполняется если вызвали контракт без передачи каких-либо данных либо перевели эфир, но в контракте нет функции receive, которая его бы обработала. Fallback функция всегда по умолчанию принимает любые данные, но чтобы принимать эфир, она должна быть помечена как payable.
+ receive функция исполняется при вызове контракта с пустым значением calldata. Это функция, которая вызывается при передаче простого эфира на адрес контракта, например, при помощи функций send и transfer. Если при передаче эфира receive функции не существует, но в контракте определена fallback функция, то будет вызываться она. Если же не будет определена и fallback функция, то контракт не сможет принимать эфир, а все попытки передать эфир на данный контракт будут вызывать исключение.
```solidity
contract TestPayable {
    uint x;
    uint y;
    // Эта функция исполняется при отправке любого сообщения на этот контракт
    // включая прием отправленного эфира (когда не определена функция receive).
    // Любой вызов с не пустой calldata на этот контракт будет исполнять
    // fallback функцию (даже если вместе с вызовом отправлеяется эфир).
    fallback() external payable { x = 1; y = msg.value; }
    // Эта функция исполняется при отправке эфира на этот контракт,
    // т.е. для всех вызовов контрактк с пустым calldata.
    receive() external payable { x = 2; y = msg.value; }
}
```