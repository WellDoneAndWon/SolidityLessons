## Типы памяти
Важная вещь, которую вам нужно понять перед началом разработки на Solidity – это где и как хранятся все данные? От этого будет зависеть какие методы работы с памятью вы будите использовать и какое количество газа за это заплатит конечный пользователь вашего смарт-контракта!

+ Storage – это постоянная память смарт-контракта, которых хранит в ней все глобальные переменные. Это самая дорогая память! Потому что данные, хранящиеся в ней, записываются в блокчейн навсегда. Это своего рода хранилище (база данных) вашего смарт-контракта.
+ Memory – это временная память, которая выделятся только на момент вызова функций смарт-контракта. Это своего рода оперативная память необходимая для вычислений. Например, в ней хранятся значения переменных, которые вы передаете в локальные функции или значение переменных которые возвращают эти функции. Стоит она намного дешевле чем storage.
+ Stack – эта память работает по принципам LIFO (“последним пришел, первым вышел”). Главным образом ее использует EVM для всех вычислений. Стоит она также как memory. Использование данного вида памяти лучше оставить на усмотрение компилятора.
+ 
## Местоположение данных в памяти
Для массивов и структур Solidity автоматически определяет, в зависимости от контекста, где должны располагаться эти данные – в storage или в memory. Например, переменные которые передаются в функцию, объявляются в функции и возвращаются функцией – хранятся в memory, а глобальные переменных хранятся в storage.

Однако, при помощи ключевых слов storage и memory вы можете переопределить это поведение и это повлияет на то, как будет работать оператор присваивания.

+ Когда существующую переменную с типом memory мы присваиваем в переменную с типом storage, то мы копируем данные из memory в storage. При этом новое хранилище storage не создается (т.к. оно уже было выделено при создании контракта)!
+ Когда существующую переменную с типом storage мы присваиваем в переменную с типом memory, то мы копируем данные из storage в memory. При этом выделяется новая память!
+ Когда переменная storage создается внутри функции локально и ей присваивается объект путем поиска из списка глобальных переменных, то она просто ссылается на данные уже размещенные в хранилище storage. При этом новое хранилище не создается!

Мы можем переопределять местоположение данных в памяти только для параметров функции и ее локальных переменных. Всякий раз, когда мы переменную с типом storage присваиваем в переменную с типом memory, у нас создается копия и ее дальнейшая модификация не влияет на состояние контракта.



## Строки
В переменных типа string вы можете хранить строковые значения, которые заключаются в одинарные или двойные кавычки. В них также есть поддержка escape символов, таких как \n, \xNN и т.д.


```solidity
string public constant name = "This is my string value";
```
Solidity не имеет возможности манипулирования строками, но есть сторонние строковые библиотеки. Например, вы можете сравнить две строки по их хэшу: ``keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))`` либо объединить две строки при помощи ``bytes.concat(bytes(s1), bytes(s2))``.

## Address
Это фиксированное 20 байтовое значение (длинна адреса в Ethereum), которое является основой во всех контрактах. При помощи данного типа вы можете указывать участников, адреса смарт-контактов и адреса собственных токенов.
```
address nameReg = 0xdfc4bccf1aec515932c2d1ae499f92bb4ce04113;
```
Адрес также может быть объявлен как payable, в таком случае на этот адрес появляется возможность отправлять эфир при помощи двух дополнительных методов, которые он приобретает: transfer и send.
```
address payable nameReg = 0xdfc4bccf1aec515932c2d1ae499f92bb4ce04113;
```
Если вы планируете объявить переменную с типом address на который хотите переводить эфир, то сделайте эту переменную с типом address payable.

Применяемые операторы: <=, <, ==, !=, >=, >

## Тип контракта
Каждый контракт имеет свой тип. Контракты могут быть преобразованы в тип адреса и обратно. Причем, преобразование контракта в тип address payable можно только в том случае, если сам контракт имеет функцию “получения и возврата” (receive or payable fallback function).

Если вы объявите локальную переменную контракта, то можете вызывать функции этого контракта. Также вы можете создавать экземпляры контракта при помощи слова new, это значит что контракт будет создаваться заново. Передав переменную контракта C в функцию type(C), вы сможете увидеть информацию о контракте.

## Словари
Словари (Mapping Type) используются для сопоставления между собой двух наборов значений, как правило разного типа. 

Синтаксис: ``mapping(_KeyType => _ValueType)``.

_KeyType может быть любым встроенным типом значения, байтами, строкой или любым контрактом или типом перечисления. _ValueType может быть любого типа, включая сопоставления, массивы и структуры.
```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.0 <0.9.0;
contract MappingExample {
    mapping(address => uint) public balances;
    function update(uint newBalance) public {
        balances[msg.sender] = newBalance;
    }
}
contract MappingUser {
    function f() public returns (uint) {
        MappingExample m = new MappingExample();
        m.update(100);
        return m.balances(address(this));
    }
}
```
## Как проверить существование ключа в словаре?
В Solidity нет такого понятие как “существование ключа в словаре”, т.к. по умолчанию он существует всегда, но равен 0. Поэтому, чтобы проверить отсутствие ключа в словаре, вам нужно проверить значение по вашему ключу возвращает 0 в соответствии с его типом. Т.е. для адреса это mapping[key] == address(0x0), для байтового массива это mapping[key] = bytes4(0x0) и т.д. Для структур – обычно в самой структуре задают дополнительный атрибут типа bool, который при заполнении структуры всегда устанавливают в true, ну и соответственно проверку наличия ключа делают по этому флагу (пример: Game[id].isValue == false).
```
// с версии 0.8.6 можно определять наличие ключа в словаре еще и так<br>if (abi.encodePacked(balances[user_id]).length > 0) {
    delete balances[addr];
}
```
